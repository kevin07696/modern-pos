# S2.2: Implement Modifier Selection Logic

**Sprint**: 2
**Story Points**: 5
**Assignee**: Developer A
**Priority**: P0 - Critical
**Dependencies**: S2.1 (Modifier Proto Enhancements)

---

## User Story

As a **backend developer**, I want **modifier selection validation logic** so that **only valid modifier combinations are accepted**.

---

## Description

Implement the domain service logic to validate modifier selections based on min/max constraints, conditional rules, and mutual exclusions. This ensures data integrity and enforces business rules at the API level.

---

## Acceptance Criteria

- [ ] Validate min/max selection constraints
- [ ] Enforce required modifier sections
- [ ] Check conditional modifier availability
- [ ] Validate mutually exclusive options
- [ ] Verify stock availability for stockable modifiers
- [ ] Calculate price adjustments (fixed and percentage)
- [ ] Return clear validation error messages
- [ ] Handle nested modifier scenarios

---

## Definition of Done

- [x] Domain service implemented
- [x] All validation rules enforced
- [x] Unit tests passing (>90% coverage)
- [x] Integration tests with database
- [x] Error messages user-friendly
- [x] Performance optimized (<100ms validation)
- [x] Code reviewed and approved

---

## Technical Details

### Modifier Validation Service

```go
// services/item-management/internal/domain/modifier_validator.go

package domain

import (
    "context"
    "fmt"
    
    itemv1 "github.com/modernpos/pos/gen/proto/go/item/v1"
)

type ModifierValidator struct {
    itemRepo     ItemRepository
    modifierRepo ModifierRepository
}

type ModifierSelection struct {
    SectionID string
    GroupID   string
    OptionID  string
    Quantity  int32
}

func (v *ModifierValidator) ValidateModifierSelections(
    ctx context.Context,
    itemID string,
    selections []*ModifierSelection,
) error {
    // 1. Get item with modifier sections
    item, err := v.itemRepo.GetByID(ctx, itemID)
    if err != nil {
        return fmt.Errorf("item not found: %w", err)
    }

    // 2. Get all modifier sections for this item
    sections := make(map[string]*itemv1.ModifierSection)
    for _, sectionID := range item.ModifierSectionIds {
        section, err := v.modifierRepo.GetSection(ctx, sectionID)
        if err != nil {
            return fmt.Errorf("modifier section not found: %w", err)
        }
        sections[sectionID] = section
    }

    // 3. Validate each required section has selections
    for _, section := range sections {
        if section.Required {
            if !v.hasSectionSelection(selections, section.Id) {
                return fmt.Errorf("modifier section '%s' is required", section.Name.Translations["en-US"])
            }
        }
    }

    // 4. Validate selection counts per section
    sectionCounts := v.countSelectionsBySection(selections)
    for sectionID, count := range sectionCounts {
        section := sections[sectionID]
        if count < section.MinSelection {
            return fmt.Errorf("modifier section '%s' requires at least %d selection(s)", 
                section.Name.Translations["en-US"], section.MinSelection)
        }
        if count > section.MaxSelection {
            return fmt.Errorf("modifier section '%s' allows at most %d selection(s)",
                section.Name.Translations["en-US"], section.MaxSelection)
        }
    }

    // 5. Validate conditional availability
    for _, selection := range selections {
        option, err := v.modifierRepo.GetOption(ctx, selection.OptionID)
        if err != nil {
            return fmt.Errorf("modifier option not found: %w", err)
        }

        // Check if option is available for this item
        if err := v.checkAvailability(ctx, option, itemID); err != nil {
            return err
        }

        // Check required options
        if len(option.RequiresOptions) > 0 {
            if !v.hasRequiredOptions(selections, option.RequiresOptions) {
                return fmt.Errorf("modifier '%s' requires other options to be selected first",
                    option.Name.Translations["en-US"])
            }
        }

        // Check mutually exclusive options
        if len(option.ExcludesOptions) > 0 {
            if v.hasExcludedOptions(selections, option.ExcludesOptions) {
                return fmt.Errorf("modifier '%s' cannot be combined with other selected options",
                    option.Name.Translations["en-US"])
            }
        }

        // Check stock availability
        if option.Stockable && option.StockQuantity < selection.Quantity {
            return fmt.Errorf("insufficient stock for modifier '%s'",
                option.Name.Translations["en-US"])
        }
    }

    return nil
}

func (v *ModifierValidator) CalculateTotalAdjustment(
    ctx context.Context,
    basePrice int64,
    selections []*ModifierSelection,
) (int64, error) {
    totalAdjustment := int64(0)

    for _, selection := range selections {
        option, err := v.modifierRepo.GetOption(ctx, selection.OptionID)
        if err != nil {
            return 0, err
        }

        adjustment := int64(0)
        switch option.PriceAdjustment.Type {
        case itemv1.PriceAdjustmentType_PRICE_ADJUSTMENT_TYPE_FIXED:
            adjustment = option.PriceAdjustment.FixedAmount.Amount
        case itemv1.PriceAdjustmentType_PRICE_ADJUSTMENT_TYPE_PERCENTAGE:
            percentageValue := float64(option.PriceAdjustment.Percentage.Value) / 10000.0
            adjustment = int64(float64(basePrice) * percentageValue)
        }

        totalAdjustment += adjustment * int64(selection.Quantity)
    }

    return totalAdjustment, nil
}

func (v *ModifierValidator) checkAvailability(
    ctx context.Context,
    option *itemv1.ModifierOption,
    itemID string,
) error {
    if option.Availability == nil {
        return nil // No restrictions
    }

    // Check item-specific availability
    if len(option.Availability.ItemIds) > 0 {
        found := false
        for _, allowedItemID := range option.Availability.ItemIds {
            if allowedItemID == itemID {
                found = true
                break
            }
        }
        if !found {
            return fmt.Errorf("modifier not available for this item")
        }
    }

    // TODO: Check time-based availability
    // TODO: Check day-of-week availability

    return nil
}

func (v *ModifierValidator) hasSectionSelection(selections []*ModifierSelection, sectionID string) bool {
    for _, sel := range selections {
        if sel.SectionID == sectionID {
            return true
        }
    }
    return false
}

func (v *ModifierValidator) countSelectionsBySection(selections []*ModifierSelection) map[string]int32 {
    counts := make(map[string]int32)
    for _, sel := range selections {
        counts[sel.SectionID] += sel.Quantity
    }
    return counts
}

func (v *ModifierValidator) hasRequiredOptions(selections []*ModifierSelection, requiredIDs []string) bool {
    selectedIDs := make(map[string]bool)
    for _, sel := range selections {
        selectedIDs[sel.OptionID] = true
    }

    for _, reqID := range requiredIDs {
        if !selectedIDs[reqID] {
            return false
        }
    }
    return true
}

func (v *ModifierValidator) hasExcludedOptions(selections []*ModifierSelection, excludedIDs []string) bool {
    for _, sel := range selections {
        for _, exID := range excludedIDs {
            if sel.OptionID == exID {
                return true
            }
        }
    }
    return false
}
```

---

## Implementation Steps

1. Create `modifier_validator.go` domain service
2. Implement ValidateModifierSelections method
3. Implement CalculateTotalAdjustment method
4. Add availability checking logic
5. Add required options validation
6. Add excluded options validation
7. Add stock availability checks
8. Create comprehensive unit tests
9. Add integration tests
10. Optimize performance

---

## Testing

### Unit Tests

```go
func TestModifierValidator_ValidateSelections(t *testing.T) {
    t.Run("valid selection", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{
            {SectionID: "sec-1", GroupID: "grp-1", OptionID: "opt-1", Quantity: 1},
        }
        
        err := validator.ValidateModifierSelections(ctx, "item-1", selections)
        assert.NoError(t, err)
    })

    t.Run("required section missing", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{}
        
        err := validator.ValidateModifierSelections(ctx, "item-1", selections)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "required")
    })

    t.Run("min selection not met", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{
            {SectionID: "sec-1", GroupID: "grp-1", OptionID: "opt-1", Quantity: 1},
        }
        
        err := validator.ValidateModifierSelections(ctx, "item-1", selections)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "at least")
    })

    t.Run("max selection exceeded", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{
            {SectionID: "sec-1", GroupID: "grp-1", OptionID: "opt-1", Quantity: 10},
        }
        
        err := validator.ValidateModifierSelections(ctx, "item-1", selections)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "at most")
    })
}

func TestModifierValidator_CalculateTotalAdjustment(t *testing.T) {
    t.Run("fixed price adjustment", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{
            {OptionID: "opt-extra-cheese", Quantity: 1}, // +$2.00
        }
        
        adjustment, err := validator.CalculateTotalAdjustment(ctx, 1000, selections)
        require.NoError(t, err)
        assert.Equal(t, int64(200), adjustment)
    })

    t.Run("percentage price adjustment", func(t *testing.T) {
        validator := setupValidator()
        
        selections := []*ModifierSelection{
            {OptionID: "opt-extra-large", Quantity: 1}, // +50%
        }
        
        adjustment, err := validator.CalculateTotalAdjustment(ctx, 1000, selections)
        require.NoError(t, err)
        assert.Equal(t, int64(500), adjustment)
    })
}
```

---

## Time Estimate

**Estimated**: 3 hours (implementation) + 2 hours (testing)
**Actual**: ___ hours

---

## Notes

- Validation logic is critical for data integrity
- Clear error messages improve UX
- Performance optimization needed for complex modifier trees
- Consider caching modifier definitions for frequently accessed items
- Future: Add time-based and location-based availability checks

---

## Related Stories

- **S2.1**: Proto Modifier Enhancements (prerequisite)
- **S2.3**: Modifier Validation API Endpoint
- **S2.10**: POS Terminal - Modifier Selection UI
