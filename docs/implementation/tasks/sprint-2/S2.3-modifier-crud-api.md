# S2.3: Modifier CRUD API Implementation

**Sprint**: 2
**Story Points**: 5
**Assignee**: Developer A
**Priority**: P0 - Critical
**Dependencies**: S2.2 (Modifier Selection Logic)

---

## User Story

As a **restaurant manager**, I want **API endpoints to manage modifiers** so that **I can configure menu customization options**.

---

## Description

Implement ConnectRPC handlers for creating, updating, and deleting modifier sections, groups, and options. Include validation, database persistence with SQLC, and proper error handling.

---

## Acceptance Criteria

- [ ] CreateModifierSection endpoint implemented
- [ ] UpdateModifierSection endpoint implemented
- [ ] DeleteModifierSection endpoint implemented (soft delete)
- [ ] CreateModifierGroup endpoint implemented
- [ ] CreateModifierOption endpoint implemented
- [ ] Validation using modifier validator service
- [ ] Database transactions for consistency
- [ ] Comprehensive error handling
- [ ] Integration tests passing

---

## Definition of Done

- [x] All CRUD endpoints implemented
- [x] SQLC queries created
- [x] ConnectRPC handlers implemented
- [x] Validation integrated
- [x] Unit tests passing (>85% coverage)
- [x] Integration tests with database
- [x] API documentation updated
- [x] Code reviewed and approved

---

## Technical Details

### ConnectRPC Handler

```go
// services/item-management/internal/handlers/modifier_handler.go

func (h *ModifierHandler) CreateModifierSection(
    ctx context.Context,
    req *connect.Request[itemv1.CreateModifierSectionRequest],
) (*connect.Response[itemv1.ModifierSection], error) {
    // Validate request
    if req.Msg.Name == nil || len(req.Msg.Name.Translations) == 0 {
        return nil, connect.NewError(connect.CodeInvalidArgument, 
            fmt.Errorf("name is required"))
    }

    if req.Msg.MaxSelection < req.Msg.MinSelection {
        return nil, connect.NewError(connect.CodeInvalidArgument,
            fmt.Errorf("max_selection must be >= min_selection"))
    }

    // Create section
    section, err := h.modifierService.CreateSection(ctx, req.Msg)
    if err != nil {
        return nil, connect.NewError(connect.CodeInternal, err)
    }

    return connect.NewResponse(section), nil
}
```

### SQLC Queries

```sql
-- queries/modifier.sql

-- name: CreateModifierSection :one
INSERT INTO modifier_sections (
    id, name, description, min_selection, max_selection, required, active
) VALUES (
    gen_random_uuid(), $1, $2, $3, $4, $5, $6
) RETURNING *;

-- name: UpdateModifierSection :one
UPDATE modifier_sections
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    min_selection = COALESCE($4, min_selection),
    max_selection = COALESCE($5, max_selection),
    required = COALESCE($6, required),
    active = COALESCE($7, active),
    updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: GetModifierSection :one
SELECT * FROM modifier_sections WHERE id = $1;

-- name: ListModifierSections :many
SELECT * FROM modifier_sections
WHERE active = $1 OR $1 IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;
```

---

## Implementation Steps

1. Create SQLC queries for modifiers
2. Run `sqlc generate`
3. Implement ModifierService domain logic
4. Create ModifierHandler with ConnectRPC
5. Add validation logic
6. Implement CreateModifierSection
7. Implement UpdateModifierSection
8. Implement CreateModifierGroup
9. Implement CreateModifierOption
10. Add error handling
11. Write unit tests
12. Write integration tests

---

## Testing

```go
func TestModifierHandler_CreateSection(t *testing.T) {
    t.Run("success", func(t *testing.T) {
        handler := setupHandler()
        
        req := connect.NewRequest(&itemv1.CreateModifierSectionRequest{
            Name: &commonv1.LocalizedString{
                Translations: map[string]string{"en-US": "Size"},
            },
            MinSelection: 1,
            MaxSelection: 1,
            Required:     true,
        })
        
        resp, err := handler.CreateModifierSection(ctx, req)
        require.NoError(t, err)
        assert.NotEmpty(t, resp.Msg.Id)
    })
}
```

---

## Time Estimate

**Estimated**: 3 hours (implementation) + 2 hours (testing)
**Actual**: ___ hours

---

## Notes

- Use database transactions for consistency
- Soft delete for modifier sections (set active=false)
- Cascade delete for groups and options
- Consider versioning for audit trail

---

## Related Stories

- **S2.2**: Modifier Selection Logic (prerequisite)
- **S2.4**: Modifier Management UI
