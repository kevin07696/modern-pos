# S3.1: Offline Mode - IndexedDB Setup

**Sprint**: 3
**Story Points**: 5
**Assignee**: Developer B
**Priority**: P0 - Critical
**Dependencies**: None

---

## User Story

As a **POS terminal**, I want **local database storage using IndexedDB** so that **I can store transactions when offline**.

---

## Description

Set up IndexedDB using Dexie.js to provide a local database for offline transaction storage. Define schemas for transactions, cached items, and sync queue with proper indexing for efficient queries.

---

## Acceptance Criteria

- [ ] Dexie.js installed and configured
- [ ] Database schema defined with proper indexes
- [ ] LocalTransaction table created
- [ ] CachedItem table created
- [ ] SyncQueue table created
- [ ] Database initialization on app load
- [ ] Migration strategy for schema changes
- [ ] Database versioning implemented
- [ ] Error handling for quota exceeded
- [ ] Developer tools integration (view data)

---

## Definition of Done

- [x] Dexie.js setup complete
- [x] All tables and indexes defined
- [x] Database initialization working
- [x] Unit tests for database operations
- [x] Error handling implemented
- [x] Documentation for schema
- [x] Code reviewed and approved

---

## Technical Details

### Install Dexie.js

```bash
cd web
npm install dexie dexie-react-hooks
npm install --save-dev @types/dexie
```

### Database Schema Definition

```typescript
// web/src/lib/db.ts

import Dexie, { Table } from 'dexie';

// Local transaction stored offline
export interface LocalTransaction {
  id: string;                          // Client-generated UUID (idempotency key)
  locationId: string;
  terminalId: string;
  userId: string;
  
  // Items
  items: LocalTransactionItem[];
  
  // Financial
  subtotal: string;                    // Decimal as string to avoid precision issues
  taxAmount: string;
  taxRate: string;
  discount: string;
  total: string;
  
  // Payment
  paymentMethod: 'CASH';               // Only cash in offline mode
  paymentAmount: string;
  changeGiven: string;
  
  // Metadata
  orderType: 'DINE_IN' | 'TAKEOUT' | 'DELIVERY';
  tableNumber?: number;
  notes?: string;
  
  // Sync status
  status: 'pending_sync' | 'synced' | 'sync_failed';
  syncAttempts: number;
  syncError?: string;
  
  // Timestamps
  createdAt: Date;                     // Local creation time
  syncedAt?: Date;                     // Server sync time
}

export interface LocalTransactionItem {
  itemId: string;
  sku: string;
  name: string;                        // Snapshot at time of sale
  quantity: number;
  unitPrice: string;
  taxRate: string;
  taxAmount: string;
  total: string;
  modifiers?: LocalModifier[];
  notes?: string;
}

export interface LocalModifier {
  modifierId: string;
  modifierOptionId: string;
  name: string;
  priceAdjustment: string;
  quantity: number;
}

// Cached menu items for offline mode
export interface CachedItem {
  id: string;
  sku: string;
  name: Record<string, string>;        // Localized names
  description?: Record<string, string>;
  price: string;
  categoryId: string;
  modifierSectionIds: string[];
  imageUrl?: string;
  active: boolean;
  sellable: boolean;
  stockable: boolean;
  
  // Cache metadata
  lastUpdated: Date;
  version: number;
}

// Cached categories
export interface CachedCategory {
  id: string;
  name: Record<string, string>;
  parentId?: string;
  displayOrder: number;
  iconUrl?: string;
  color?: string;
  active: boolean;
  lastUpdated: Date;
}

// Cached modifier sections
export interface CachedModifierSection {
  id: string;
  name: Record<string, string>;
  minSelection: number;
  maxSelection: number;
  required: boolean;
  groups: CachedModifierGroup[];
  lastUpdated: Date;
}

export interface CachedModifierGroup {
  id: string;
  name: Record<string, string>;
  displayOrder: number;
  options: CachedModifierOption[];
}

export interface CachedModifierOption {
  id: string;
  name: Record<string, string>;
  priceAdjustment: string;
  displayOrder: number;
  active: boolean;
}

// Sync queue for operations to sync when online
export interface SyncQueueItem {
  id: string;
  operation: 'create_transaction' | 'update_stock' | 'create_customer';
  entityType: 'transaction' | 'stock' | 'customer';
  entityId: string;
  payload: any;                        // JSON payload for API call
  
  // Retry logic
  createdAt: Date;
  attempts: number;
  maxAttempts: number;
  lastAttempt?: Date;
  nextRetry?: Date;                    // Exponential backoff
  error?: string;
  
  // Priority
  priority: number;                    // Higher number = higher priority
}

// Dexie database class
export class POSDatabase extends Dexie {
  transactions!: Table<LocalTransaction, string>;
  items!: Table<CachedItem, string>;
  categories!: Table<CachedCategory, string>;
  modifierSections!: Table<CachedModifierSection, string>;
  syncQueue!: Table<SyncQueueItem, string>;

  constructor() {
    super('modern-pos-db');

    // Version 1: Initial schema
    this.version(1).stores({
      transactions: 'id, status, createdAt, syncedAt, locationId',
      items: 'id, sku, categoryId, active, sellable, lastUpdated',
      categories: 'id, parentId, active, lastUpdated',
      modifierSections: 'id, lastUpdated',
      syncQueue: 'id, operation, entityType, entityId, createdAt, attempts, priority, nextRetry',
    });

    // Version 2: Add indexes for better querying (future migration)
    // this.version(2).stores({
    //   transactions: 'id, status, createdAt, syncedAt, locationId, [status+createdAt]',
    // });
  }
}

// Export singleton instance
export const db = new POSDatabase();

// Database initialization
export async function initializeDatabase(): Promise<void> {
  try {
    await db.open();
    console.log('✓ IndexedDB initialized successfully');
    
    // Check storage quota
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      const percentUsed = ((estimate.usage || 0) / (estimate.quota || 1)) * 100;
      console.log(`Storage used: ${percentUsed.toFixed(2)}%`);
      
      if (percentUsed > 80) {
        console.warn('⚠ Storage quota > 80%, consider cleanup');
      }
    }
  } catch (error) {
    console.error('✗ Failed to initialize IndexedDB:', error);
    throw error;
  }
}

// Cleanup old synced transactions (keep last 30 days)
export async function cleanupOldTransactions(): Promise<number> {
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  
  const deleted = await db.transactions
    .where('status')
    .equals('synced')
    .and(tx => tx.syncedAt !== undefined && tx.syncedAt < thirtyDaysAgo)
    .delete();
    
  console.log(`Cleaned up ${deleted} old transactions`);
  return deleted;
}

// Clear all data (for testing/debugging)
export async function clearAllData(): Promise<void> {
  await db.transactions.clear();
  await db.items.clear();
  await db.categories.clear();
  await db.modifierSections.clear();
  await db.syncQueue.clear();
  console.log('✓ All data cleared');
}
```

### React Hook for Database Status

```typescript
// web/src/hooks/useDatabaseStatus.ts

import { useState, useEffect } from 'react';
import { db } from '@/lib/db';
import { useLiveQuery } from 'dexie-react-hooks';

export function useDatabaseStatus() {
  const [isInitialized, setIsInitialized] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const transactionCount = useLiveQuery(
    () => db.transactions.count(),
    []
  );
  
  const pendingCount = useLiveQuery(
    () => db.transactions.where('status').equals('pending_sync').count(),
    []
  );
  
  const itemCount = useLiveQuery(
    () => db.items.count(),
    []
  );
  
  useEffect(() => {
    initializeDatabase()
      .then(() => setIsInitialized(true))
      .catch(setError);
  }, []);
  
  return {
    isInitialized,
    error,
    transactionCount: transactionCount ?? 0,
    pendingCount: pendingCount ?? 0,
    itemCount: itemCount ?? 0,
  };
}
```

---

## Implementation Steps

1. Install Dexie.js and TypeScript types
2. Create `lib/db.ts` with schema definitions
3. Define all interfaces (LocalTransaction, CachedItem, etc.)
4. Create POSDatabase class extending Dexie
5. Define table schemas with indexes
6. Implement initializeDatabase function
7. Add storage quota checking
8. Implement cleanup functions
9. Create React hooks for database status
10. Test database operations
11. Add error handling for quota exceeded
12. Document schema and usage

---

## Testing

### Unit Tests

```typescript
import { db, initializeDatabase, clearAllData } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';

describe('IndexedDB Setup', () => {
  beforeEach(async () => {
    await initializeDatabase();
    await clearAllData();
  });

  it('should initialize database', async () => {
    expect(db.isOpen()).toBe(true);
  });

  it('should create transaction', async () => {
    const transaction = {
      id: uuidv4(),
      locationId: 'loc-1',
      terminalId: 'term-1',
      userId: 'user-1',
      items: [],
      subtotal: '10.00',
      taxAmount: '0.88',
      taxRate: '0.0875',
      discount: '0.00',
      total: '10.88',
      paymentMethod: 'CASH' as const,
      paymentAmount: '20.00',
      changeGiven: '9.12',
      orderType: 'DINE_IN' as const,
      status: 'pending_sync' as const,
      syncAttempts: 0,
      createdAt: new Date(),
    };

    await db.transactions.add(transaction);

    const retrieved = await db.transactions.get(transaction.id);
    expect(retrieved).toBeDefined();
    expect(retrieved?.total).toBe('10.88');
  });

  it('should query pending transactions', async () => {
    // Add test data
    await db.transactions.bulkAdd([
      { id: '1', status: 'pending_sync', /* ... */ },
      { id: '2', status: 'synced', /* ... */ },
      { id: '3', status: 'pending_sync', /* ... */ },
    ]);

    const pending = await db.transactions
      .where('status')
      .equals('pending_sync')
      .toArray();

    expect(pending.length).toBe(2);
  });
});
```

### Manual Testing

```typescript
// In browser console
import { db } from './lib/db';

// Check database is open
console.log(db.isOpen()); // true

// Add test transaction
await db.transactions.add({
  id: 'test-1',
  // ... fill in required fields
});

// Query transactions
await db.transactions.toArray();

// Check storage usage
if ('storage' in navigator) {
  const estimate = await navigator.storage.estimate();
  console.log('Usage:', estimate.usage, 'Quota:', estimate.quota);
}
```

---

## Time Estimate

**Estimated**: 3 hours (setup) + 1 hour (testing) + 1 hour (documentation)
**Actual**: ___ hours

---

## Notes

- IndexedDB provides 50MB+ storage (browser-dependent)
- Dexie.js simplifies IndexedDB API significantly
- Use string for decimal values to avoid floating-point errors
- Implement cleanup strategy to avoid quota exceeded errors
- Consider implementing data export for backup
- IndexedDB is origin-specific (cannot share across domains)
- Monitor storage usage to prevent quota errors

---

## Related Stories

- **S3.2**: Offline Mode - Connectivity Detection (next step)
- **S3.3**: Offline Mode - Local Transaction Storage (uses this database)
- **S3.4**: Offline Mode - Sync Queue Manager (uses sync queue table)
