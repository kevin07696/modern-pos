# S1.2: Configure Docker Compose

**Sprint**: 1
**Story Points**: 3
**Assignee**: Both
**Priority**: P0 - Critical
**Dependencies**: S1.1 (Setup Monorepo)

---

## User Story

As a **developer**, I want **Docker Compose configured with PostgreSQL and Redis** so that **I have a consistent local development environment**.

---

## Description

Set up Docker Compose configuration to run all infrastructure dependencies locally. This includes PostgreSQL 15+ for database storage, Redis 7+ for caching and pub/sub messaging, and network configuration to allow services to communicate.

The setup should support hot-reloading during development, persist data between restarts, and provide health checks for all containers.

---

## Acceptance Criteria

### Docker Compose Setup
- [ ] `docker-compose.yml` created in project root
- [ ] PostgreSQL 15+ container configured
- [ ] Redis 7+ container configured
- [ ] All containers on same Docker network
- [ ] Volume mounts for data persistence

### PostgreSQL Configuration
- [ ] postgres:15-alpine image
- [ ] Database: `modern_pos`
- [ ] User: `pos_user`
- [ ] Password: Environment variable
- [ ] Port: 5432 mapped to host
- [ ] Health check configured
- [ ] Initial database creation script

### Redis Configuration
- [ ] redis:7-alpine image
- [ ] Port: 6379 mapped to host
- [ ] Health check configured
- [ ] Persistence enabled (AOF or RDB)

### Development Workflow
- [ ] `docker-compose up` starts all services
- [ ] `docker-compose down` stops cleanly
- [ ] Data persists between restarts
- [ ] Logs accessible via `docker-compose logs`

---

## Definition of Done

- [x] docker-compose.yml file created
- [x] PostgreSQL container starts successfully
- [x] Redis container starts successfully
- [x] Can connect to PostgreSQL from host
- [x] Can connect to Redis from host
- [x] Health checks passing
- [x] .env.example file with required variables
- [x] Documentation in README
- [x] Tested on macOS and Linux
- [x] Code reviewed and approved

---

## Technical Details

### Docker Compose File Structure

```yaml
version: '3.9'

services:
  postgres:
    image: postgres:15-alpine
    container_name: modern-pos-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-modern_pos}
      POSTGRES_USER: ${POSTGRES_USER:-pos_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U pos_user -d modern_pos"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - pos-network

  redis:
    image: redis:7-alpine
    container_name: modern-pos-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks:
      - pos-network

networks:
  pos-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
```

### .env.example File

```bash
# PostgreSQL Configuration
POSTGRES_DB=modern_pos
POSTGRES_USER=pos_user
POSTGRES_PASSWORD=your_secure_password_here

# Redis Configuration
REDIS_URL=redis://localhost:6379

# Application Configuration
APP_ENV=development
LOG_LEVEL=debug
```

### Initial Database Script

```sql
-- scripts/init-db.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create schemas for each service
CREATE SCHEMA IF NOT EXISTS platform;
CREATE SCHEMA IF NOT EXISTS item_management;
CREATE SCHEMA IF NOT EXISTS order_fulfillment;
CREATE SCHEMA IF NOT EXISTS communication;

-- Grant privileges
GRANT ALL PRIVILEGES ON SCHEMA platform TO pos_user;
GRANT ALL PRIVILEGES ON SCHEMA item_management TO pos_user;
GRANT ALL PRIVILEGES ON SCHEMA order_fulfillment TO pos_user;
GRANT ALL PRIVILEGES ON SCHEMA communication TO pos_user;
```

---

## Implementation Steps

1. Create `docker-compose.yml` in project root
2. Define PostgreSQL service with version 15-alpine
3. Define Redis service with version 7-alpine
4. Configure Docker network for service communication
5. Create volume definitions for data persistence
6. Add health check configurations
7. Create `scripts/init-db.sql` for database initialization
8. Create `.env.example` with all required variables
9. Copy `.env.example` to `.env` for local development
10. Test: Run `docker-compose up -d`
11. Verify: Check container status `docker-compose ps`
12. Verify: Connect to PostgreSQL using psql or DBeaver
13. Verify: Connect to Redis using redis-cli
14. Document commands in README

---

## Testing

### Manual Test Cases

**Test 1: Start services**
```bash
docker-compose up -d

# Expected: Both containers start successfully
# Verify: docker-compose ps shows "healthy" status
```

**Test 2: PostgreSQL connection**
```bash
psql -h localhost -U pos_user -d modern_pos

# Expected: Successfully connects to database
# Verify: Can run SELECT 1;
```

**Test 3: Redis connection**
```bash
redis-cli ping

# Expected: PONG response
# Verify: Can SET/GET test values
```

**Test 4: Data persistence**
```bash
# In PostgreSQL: CREATE TABLE test (id INT);
docker-compose down
docker-compose up -d
# In PostgreSQL: Check table still exists

# Expected: Data persists after restart
```

**Test 5: Health checks**
```bash
docker-compose ps

# Expected: All services show "healthy" status
```

---

## README Documentation

Add to project README:

```markdown
## Local Development Setup

### Prerequisites
- Docker Desktop 4.0+
- Docker Compose 2.0+

### Start Services

```bash
# Copy environment template
cp .env.example .env

# Start all infrastructure services
docker-compose up -d

# View logs
docker-compose logs -f

# Check service health
docker-compose ps
```

### Connect to Services

**PostgreSQL**:
```bash
psql -h localhost -U pos_user -d modern_pos
# Password: (from .env file)
```

**Redis**:
```bash
redis-cli
```

### Stop Services

```bash
# Stop containers (preserves data)
docker-compose stop

# Stop and remove containers (preserves volumes)
docker-compose down

# Stop and remove everything including data
docker-compose down -v
```
```

---

## Time Estimate

**Estimated**: 2 hours (setup) + 1 hour (testing)
**Actual**: ___ hours

---

## Notes

- Use alpine images for smaller container sizes
- PostgreSQL data persists in Docker volume (not bind mount) for performance
- Redis AOF persistence ensures no data loss on restart
- Health checks prevent services starting before dependencies are ready
- init-db.sql runs only on first container creation
- For production, use different compose file with secrets management

---

## Related Stories

- **S1.1**: Setup Monorepo Structure (prerequisite)
- **S1.8**: Generate Code from Protos (uses these services)
- **S2.16**: Production Deployment Setup (production compose file)
