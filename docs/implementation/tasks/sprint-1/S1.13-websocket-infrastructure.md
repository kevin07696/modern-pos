# S1.13: WebSocket Infrastructure

**Sprint**: 1
**Story Points**: 8
**Assignee**: Developer B
**Priority**: P0 - Critical
**Dependencies**: S1.11 (Publish sale.completed Event)

---

## User Story

As a **system**, I want **WebSocket infrastructure for real-time updates** so that **kitchen displays can receive order notifications instantly without polling**.

---

## Description

Implement WebSocket server in the Communication Service that subscribes to Redis pub/sub events and broadcasts them to connected clients. This enables real-time updates for kitchen displays when new orders are completed. The frontend will connect via WebSocket and maintain persistent connections with automatic reconnection.

This is critical infrastructure for the kitchen display feature (S1.14).

---

## Acceptance Criteria

### Backend (Communication Service)
- [ ] WebSocket server running on /ws endpoint
- [ ] JWT authentication on WebSocket connection
- [ ] Subscribe to Redis `sales:completed` channel
- [ ] Transform events to WebSocket messages
- [ ] Broadcast to connected clients by location
- [ ] Handle client connections/disconnections
- [ ] Heartbeat/ping every 30 seconds
- [ ] Graceful shutdown

### Frontend (WebSocket Client)
- [ ] WebSocket hook for React
- [ ] Auto-connect with JWT token
- [ ] Automatic reconnection with exponential backoff
- [ ] Connection status indicator
- [ ] Event subscription system
- [ ] Error handling and logging

---

## Definition of Done

- [x] WebSocket server implemented in Go
- [x] Redis subscription working
- [x] JWT authentication on WebSocket
- [x] Client connection management
- [x] Frontend WebSocket hook
- [x] Reconnection logic implemented
- [x] Integration tests
- [x] Manual testing completed
- [x] Code reviewed and approved

---

## Technical Details

### Backend Implementation

```go
// services/communication/internal/websocket/server.go

package websocket

import (
    "context"
    "encoding/json"
    "sync"
    "time"

    "github.com/gorilla/websocket"
    "github.com/redis/go-redis/v9"
)

type Server struct {
    clients    map[*Client]bool
    clientsMux sync.RWMutex
    upgrader   websocket.Upgrader
    redis      *redis.Client
    jwtValidator JWTValidator
}

type Client struct {
    conn       *websocket.Conn
    send       chan []byte
    locationID string
    userID     string
}

func NewServer(redisClient *redis.Client, jwtValidator JWTValidator) *Server {
    return &Server{
        clients:      make(map[*Client]bool),
        redis:        redisClient,
        jwtValidator: jwtValidator,
        upgrader: websocket.Upgrader{
            CheckOrigin: func(r *http.Request) bool {
                // TODO: Verify origin in production
                return true
            },
        },
    }
}

func (s *Server) HandleConnection(w http.ResponseWriter, r *http.Request) {
    // 1. Authenticate via JWT
    token := r.URL.Query().Get("token")
    claims, err := s.jwtValidator.ValidateToken(token)
    if err != nil {
        http.Error(w, "Unauthorized", http.StatusUnauthorized)
        return
    }

    // 2. Upgrade connection
    conn, err := s.upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Error("upgrade failed", "error", err)
        return
    }

    // 3. Create client
    client := &Client{
        conn:       conn,
        send:       make(chan []byte, 256),
        locationID: claims.LocationID,
        userID:     claims.UserID,
    }

    // 4. Register client
    s.clientsMux.Lock()
    s.clients[client] = true
    s.clientsMux.Unlock()

    log.Info("client connected", "user_id", client.userID, "location_id", client.locationID)

    // 5. Start goroutines
    go client.writePump()
    go client.readPump(s)
}

func (c *Client) writePump() {
    ticker := time.NewTicker(30 * time.Second)
    defer func() {
        ticker.Stop()
        c.conn.Close()
    }()

    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {
                return
            }

        case <-ticker.C:
            // Send ping
            c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
            if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

func (c *Client) readPump(s *Server) {
    defer func() {
        s.unregisterClient(c)
        c.conn.Close()
    }()

    c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    c.conn.SetPongHandler(func(string) error {
        c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })

    for {
        _, _, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Error("unexpected close", "error", err)
            }
            break
        }
    }
}

// Subscribe to Redis and broadcast to clients
func (s *Server) SubscribeToEvents(ctx context.Context) {
    pubsub := s.redis.Subscribe(ctx, "sales:completed")
    defer pubsub.Close()

    ch := pubsub.Channel()

    for msg := range ch {
        var event map[string]interface{}
        if err := json.Unmarshal([]byte(msg.Payload), &event); err != nil {
            log.Error("failed to unmarshal event", "error", err)
            continue
        }

        locationID, _ := event["location_id"].(string)

        // Broadcast to clients in this location
        s.broadcastToLocation(locationID, []byte(msg.Payload))
    }
}

func (s *Server) broadcastToLocation(locationID string, message []byte) {
    s.clientsMux.RLock()
    defer s.clientsMux.RUnlock()

    for client := range s.clients {
        if client.locationID == locationID {
            select {
            case client.send <- message:
            default:
                // Channel full, skip
            }
        }
    }
}
```

### Frontend Hook

```typescript
// hooks/useWebSocket.ts

import { useEffect, useRef, useState } from 'react';

interface UseWebSocketOptions {
  url: string;
  token: string;
  onMessage?: (event: MessageEvent) => void;
  onOpen?: () => void;
  onClose?: () => void;
  onError?: (error: Event) => void;
}

export function useWebSocket({
  url,
  token,
  onMessage,
  onOpen,
  onClose,
  onError,
}: UseWebSocketOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [reconnectAttempt, setReconnectAttempt] = useState(0);
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();

  const connect = () => {
    try {
      const wsUrl = `${url}?token=${token}`;
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('WebSocket connected');
        setIsConnected(true);
        setReconnectAttempt(0);
        onOpen?.();
      };

      ws.onmessage = (event) => {
        onMessage?.(event);
      };

      ws.onclose = () => {
        console.log('WebSocket disconnected');
        setIsConnected(false);
        onClose?.();

        // Automatic reconnection with exponential backoff
        const delay = Math.min(1000 * 2 ** reconnectAttempt, 30000);
        reconnectTimeoutRef.current = setTimeout(() => {
          console.log(`Reconnecting... (attempt ${reconnectAttempt + 1})`);
          setReconnectAttempt((prev) => prev + 1);
          connect();
        }, delay);
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        onError?.(error);
      };

      wsRef.current = ws;
    } catch (error) {
      console.error('Failed to create WebSocket:', error);
    }
  };

  useEffect(() => {
    connect();

    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      wsRef.current?.close();
    };
  }, [url, token]);

  const send = (data: string | object) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      const message = typeof data === 'string' ? data : JSON.stringify(data);
      wsRef.current.send(message);
    } else {
      console.warn('WebSocket not connected, cannot send message');
    }
  };

  return {
    isConnected,
    send,
    reconnectAttempt,
  };
}
```

---

## Implementation Steps

### Backend
1. Add WebSocket library (`github.com/gorilla/websocket`)
2. Create WebSocket server struct
3. Implement connection handler with JWT auth
4. Implement client management (register/unregister)
5. Implement write pump (send messages to client)
6. Implement read pump (receive pings/pongs)
7. Subscribe to Redis `sales:completed` channel
8. Broadcast events to clients by location
9. Add heartbeat/ping mechanism
10. Add graceful shutdown

### Frontend
11. Create `useWebSocket` hook
12. Implement connection logic
13. Implement automatic reconnection
14. Add exponential backoff
15. Add connection status state
16. Test with mock WebSocket server

---

## Testing

### Backend Test

```go
func TestWebSocketServer(t *testing.T) {
    // Setup test server
    server := setupTestWebSocketServer(t)
    defer server.Close()

    // Connect client
    wsURL := "ws" + strings.TrimPrefix(server.URL, "http") + "/ws?token=test-token"
    ws, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
    require.NoError(t, err)
    defer ws.Close()

    // Publish Redis event
    event := map[string]interface{}{
        "event_type": "sale.completed",
        "sale_id":    "123",
        "location_id": "loc-123",
    }
    publishEvent(t, event)

    // Verify client receives message
    _, message, err := ws.ReadMessage()
    require.NoError(t, err)

    var received map[string]interface{}
    json.Unmarshal(message, &received)
    assert.Equal(t, "sale.completed", received["event_type"])
}
```

### Frontend Test

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { useWebSocket } from './useWebSocket';

describe('useWebSocket', () => {
  it('connects and receives messages', async () => {
    const onMessage = vi.fn();

    const { result } = renderHook(() =>
      useWebSocket({
        url: 'ws://localhost:8080/ws',
        token: 'test-token',
        onMessage,
      })
    );

    await waitFor(() => {
      expect(result.current.isConnected).toBe(true);
    });

    // Simulate server message
    server.send(JSON.stringify({ type: 'test' }));

    await waitFor(() => {
      expect(onMessage).toHaveBeenCalled();
    });
  });
});
```

---

## Time Estimate

**Estimated**: 4 hours (backend) + 2 hours (frontend) + 2 hours (testing)
**Actual**: ___ hours

---

## Notes

- WebSocket authenticated with JWT query parameter
- Alternative: Send JWT in first message after connection
- Heartbeat prevents connection timeout (30s ping)
- Automatic reconnection prevents manual refresh
- Exponential backoff prevents server overload
- Location-based filtering ensures kitchen only sees their orders
- Consider using Socket.IO for easier setup (future)
- For production, use Redis Cluster for pub/sub scalability

---

## Related Stories

- **S1.11**: Publish sale.completed Event (provides events)
- **S1.14**: Kitchen Display UI (uses this infrastructure)
- **S3.13**: Order Status Updates (extends WebSocket usage)
