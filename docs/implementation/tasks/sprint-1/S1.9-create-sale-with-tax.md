# S1.9: Create Sale with Tax Calculation

**Sprint**: 1  
**Story Points**: 8  
**Assignee**: Developer A  
**Priority**: P0 - Critical  
**Dependencies**: S1.7 (Platform Service Tax Rate)

---

## User Story

As a **cashier**, I want to **create a sale with automatic tax calculation** so that **customers are charged the correct tax amount based on the store location**.

---

## Description

Implement the CreateSale domain service in the Order Fulfillment Service. This service will accept a list of items, fetch the tax rate from the Platform Service, calculate line totals with tax, and persist the sale to the database.

Tax rates are fetched from the Platform Service and snapshotted in each sale_item record to preserve historical accuracy even if tax rates change later.

---

## Acceptance Criteria

### Given a valid sale request
- [ ] Sale is created with status 'pending'
- [ ] UUID generated (or used from request if offline sync)
- [ ] Display number generated (daily counter per location: 1, 2, 3...)
- [ ] Tax rate fetched from Platform Service by location_id
- [ ] Each sale_item has tax_rate snapshotted
- [ ] Line totals calculated: quantity × unit_price
- [ ] Tax amount calculated: line_total × tax_rate
- [ ] Sale totals calculated: subtotal, tax_amount, total
- [ ] Sale and sale_items persisted in database transaction
- [ ] Returns sale with all calculated values

### Given invalid request
- [ ] Returns error if items array is empty
- [ ] Returns error if location_id is invalid
- [ ] Returns error if Platform Service unavailable
- [ ] Returns error if item price is negative

---

## Definition of Done

- [x] Domain service implemented in `sale_service.go`
- [x] Database transaction used for sale + items
- [x] Unit tests for tax calculation (3+ test cases)
- [x] Integration test with mock Platform Service
- [x] Integration test with real database (testcontainers)
- [x] Error handling for all failure scenarios
- [x] Logging added for debugging
- [x] Code reviewed and approved
- [x] Deployed to dev environment

---

## Technical Details

### Database Schema
```sql
CREATE TABLE sales (
    id UUID PRIMARY KEY,
    display_number INT NOT NULL,
    location_id UUID NOT NULL,
    user_id UUID NOT NULL,
    subtotal DECIMAL(12,2) NOT NULL,
    tax_amount DECIMAL(12,2) NOT NULL,
    total DECIMAL(12,2) NOT NULL,
    status VARCHAR(30) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    -- Unique daily counter per location
    UNIQUE(location_id, display_number, DATE(created_at))
);

CREATE INDEX idx_sales_location_created ON sales(location_id, created_at DESC);
CREATE INDEX idx_sales_display_number ON sales(location_id, display_number, created_at);

CREATE TABLE sale_items (
    id UUID PRIMARY KEY,
    sale_id UUID NOT NULL REFERENCES sales(id),
    item_id UUID NOT NULL,
    name VARCHAR(255) NOT NULL,
    quantity DECIMAL(10,3) NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    tax_rate DECIMAL(5,4) NOT NULL,  -- Snapshot!
    tax_amount DECIMAL(10,2) NOT NULL,
    total DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Tax Calculation Logic
```go
// 1. Fetch tax rate from Platform Service
taxRate := platformClient.GetTaxRate(ctx, locationID)

// 2. For each item:
lineSubtotal := quantity * unitPrice
lineTaxAmount := lineSubtotal * taxRate
lineTotal := lineSubtotal + lineTaxAmount

// 3. Sum all lines:
saleSubtotal := sum(lineSubtotals)
saleTaxAmount := sum(lineTaxAmounts)
saleTotal := saleSubtotal + saleTaxAmount
```

---

## Implementation Steps

1. Create `sale_service.go` with CreateSale function
2. Implement UUID generation (or accept from request for offline sync)
3. Implement display_number generation (daily counter per location)
4. Create Platform Service client to fetch tax rate
5. Implement line item calculation loop
6. Calculate sale totals
7. Persist sale and items in database transaction
8. Add error handling and validation
9. Write unit tests for calculations
10. Write integration tests with testcontainers

### Display Number Generation Logic
```go
func (s *SaleService) generateDisplayNumber(ctx context.Context, locationID string, date time.Time) (int32, error) {
    // Query: SELECT MAX(display_number) FROM sales
    // WHERE location_id = ? AND DATE(created_at) = ?
    var maxNum int32
    err := s.db.QueryRow(ctx,
        `SELECT COALESCE(MAX(display_number), 0) FROM sales
         WHERE location_id = $1 AND DATE(created_at) = $2`,
        locationID, date).Scan(&maxNum)

    return maxNum + 1, err
}
```

---

## Testing

### Unit Tests
```go
func TestCalculateTax(t *testing.T) {
    // Given
    subtotal := decimal.NewFromFloat(100.00)
    taxRate := decimal.NewFromFloat(0.0875)
    
    // When
    taxAmount := subtotal.Mul(taxRate)
    
    // Then
    assert.Equal(t, "8.75", taxAmount.String())
}
```

### Integration Test
```go
func TestCreateSale_Integration(t *testing.T) {
    // Setup testcontainer PostgreSQL
    
    // Given
    req := &CreateSaleRequest{
        LocationID: "loc-123",
        Items: []*SaleItemRequest{
            {ItemID: "item-1", Quantity: 2, UnitPrice: "10.00"},
        },
    }
    
    // When
    sale, err := saleService.CreateSale(ctx, req)
    
    // Then
    require.NoError(t, err)
    assert.Equal(t, "20.00", sale.Subtotal.String())
    assert.Equal(t, "1.75", sale.TaxAmount.String())
    assert.Equal(t, "21.75", sale.Total.String())
}
```

---

## Time Estimate

**Estimated**: 4 hours (implementation) + 2 hours (tests)  
**Actual**: ___ hours

---

## Notes

- Use decimal.Decimal for all monetary calculations (avoid float precision issues)
- Tax rate is snapshotted at sale creation time
- **Dual identifier system**:
  - `id` (UUID): Primary key, generated server-side (or accepted from offline device)
  - `display_number` (int32): Customer-facing number, resets daily per location (#1, #2, #3...)
- Display number generation uses MAX() + 1 pattern within database transaction
- UNIQUE constraint ensures no duplicate display numbers per location per day
- Database transaction prevents partial sale creation

---

## Related Stories

- **S1.7**: Platform Service - Get Tax Rate endpoint
- **S1.10**: Order Fulfillment - Process Cash Payment
- **S1.11**: Kitchen Display - Receive New Orders
