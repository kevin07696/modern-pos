# S1.12: Item List Component

**Sprint**: 1
**Story Points**: 5
**Assignee**: Developer B
**Priority**: P0 - Critical
**Dependencies**: S1.8 (Generated Proto Code)

---

## User Story

As a **cashier**, I want to **browse menu items by category** so that **I can quickly select items when taking orders at the POS terminal**.

---

## Description

Build the frontend item list component that displays sellable items grouped by categories. The component fetches data from the Item Management Service using ConnectRPC, implements category filtering, search functionality, and allows adding items to the current order.

This is a core POS UI component that cashiers will use constantly throughout the day.

---

## Acceptance Criteria

### Display Functionality
- [ ] Shows all active, sellable items
- [ ] Items grouped by category
- [ ] Category tabs/filters for navigation
- [ ] Item cards show: name, price, image (if available)
- [ ] Grid layout responsive to screen size
- [ ] Loading states while fetching data
- [ ] Empty state when no items found

### Interaction
- [ ] Click item card to add to order
- [ ] Search bar filters items by name/SKU
- [ ] Category filter updates item list
- [ ] Visual feedback on item selection
- [ ] Shows out-of-stock indicator (future)

### Data Management
- [ ] Uses TanStack Query for data fetching
- [ ] Caches item list (5 minute stale time)
- [ ] Refetch on window focus
- [ ] Error handling with retry
- [ ] Optimistic updates when available

---

## Definition of Done

- [x] ItemList component implemented
- [x] CategoryFilter component implemented
- [x] ItemCard component implemented
- [x] SearchBar component implemented
- [x] ConnectRPC client integration
- [x] TanStack Query hooks
- [x] Unit tests for components
- [x] Manual testing completed
- [x] Responsive design verified
- [x] Code reviewed and approved

---

## Technical Details

### Component Structure

```
ItemList.tsx
├── CategoryFilter.tsx
├── SearchBar.tsx
└── ItemCard.tsx
```

### Implementation

```typescript
// components/ItemList.tsx
import { useQuery } from '@tanstack/react-query';
import { createConnectTransport } from '@connectrpc/connect-web';
import { createPromiseClient } from '@connectrpc/connect';
import { ItemManagementService } from '@/gen/item/v1/item_service_connect';

const transport = createConnectTransport({
  baseUrl: import.meta.env.VITE_API_URL,
});

const itemClient = createPromiseClient(ItemManagementService, transport);

export function ItemList() {
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState('');

  // Fetch items
  const { data, isLoading, error } = useQuery({
    queryKey: ['items', selectedCategory, searchQuery],
    queryFn: async () => {
      const response = await itemClient.listItems({
        categoryId: selectedCategory || undefined,
        searchQuery: searchQuery || undefined,
        sellable: true,
        active: true,
        pagination: {
          page: 1,
          pageSize: 100,
        },
      });
      return response.items;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    refetchOnWindowFocus: true,
  });

  // Fetch categories
  const { data: categories } = useQuery({
    queryKey: ['categories'],
    queryFn: async () => {
      const response = await itemClient.listCategories({
        active: true,
        pagination: { page: 1, pageSize: 50 },
      });
      return response.categories;
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
  });

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div className="item-list">
      <SearchBar value={searchQuery} onChange={setSearchQuery} />

      <CategoryFilter
        categories={categories || []}
        selected={selectedCategory}
        onSelect={setSelectedCategory}
      />

      <div className="item-grid">
        {data?.map((item) => (
          <ItemCard
            key={item.id}
            item={item}
            onSelect={(item) => addItemToOrder(item)}
          />
        ))}
      </div>

      {data?.length === 0 && (
        <EmptyState message="No items found" />
      )}
    </div>
  );
}
```

### ItemCard Component

```typescript
// components/ItemCard.tsx
import { Item } from '@/gen/item/v1/item_service_pb';

interface ItemCardProps {
  item: Item;
  onSelect: (item: Item) => void;
}

export function ItemCard({ item, onSelect }: ItemCardProps) {
  const price = formatMoney(item.price);
  const name = item.name?.translations['en-US'] || 'Unnamed Item';

  return (
    <button
      className="item-card"
      onClick={() => onSelect(item)}
    >
      {item.imageUrl && (
        <img
          src={item.imageUrl}
          alt={name}
          className="item-image"
        />
      )}

      <div className="item-details">
        <h3 className="item-name">{name}</h3>
        <p className="item-price">{price}</p>
      </div>

      {!item.sellable && (
        <div className="badge unavailable">Unavailable</div>
      )}
    </button>
  );
}

// utils/format.ts
export function formatMoney(money?: { amount: bigint; currencyCode: string }): string {
  if (!money) return '$0.00';

  const dollars = Number(money.amount) / 100;
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: money.currencyCode,
  }).format(dollars);
}
```

### CategoryFilter Component

```typescript
// components/CategoryFilter.tsx
import { Category } from '@/gen/item/v1/item_service_pb';

interface CategoryFilterProps {
  categories: Category[];
  selected: string | null;
  onSelect: (categoryId: string | null) => void;
}

export function CategoryFilter({ categories, selected, onSelect }: CategoryFilterProps) {
  return (
    <div className="category-filter">
      <button
        className={selected === null ? 'active' : ''}
        onClick={() => onSelect(null)}
      >
        All Items
      </button>

      {categories.map((category) => (
        <button
          key={category.id}
          className={selected === category.id ? 'active' : ''}
          onClick={() => onSelect(category.id)}
        >
          {category.name?.translations['en-US'] || 'Category'}
        </button>
      ))}
    </div>
  );
}
```

---

## Implementation Steps

1. Create `components/ItemList.tsx`
2. Set up ConnectRPC client for Item Management Service
3. Create TanStack Query hooks for items and categories
4. Implement category filtering logic
5. Implement search functionality
6. Create `ItemCard.tsx` component
7. Create `CategoryFilter.tsx` component
8. Create `SearchBar.tsx` component
9. Add loading and error states
10. Add empty state
11. Implement money formatting utility
12. Add CSS/styling (Tailwind)
13. Write component tests
14. Manual testing with mock data
15. Integration testing with backend

---

## Testing

### Component Tests

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ItemList } from './ItemList';

describe('ItemList', () => {
  it('renders items', async () => {
    const queryClient = new QueryClient();
    render(
      <QueryClientProvider client={queryClient}>
        <ItemList />
      </QueryClientProvider>
    );

    // Wait for items to load
    expect(await screen.findByText('Coffee')).toBeInTheDocument();
    expect(screen.getByText('$3.50')).toBeInTheDocument();
  });

  it('filters by category', async () => {
    // Test category filtering
    const categoryButton = screen.getByText('Beverages');
    fireEvent.click(categoryButton);

    // Should only show beverage items
    expect(await screen.findByText('Coffee')).toBeInTheDocument();
    expect(screen.queryByText('Burger')).not.toBeInTheDocument();
  });

  it('searches items', async () => {
    const searchInput = screen.getByPlaceholderText('Search items...');
    fireEvent.change(searchInput, { target: { value: 'coff' } });

    // Should filter to coffee items
    expect(await screen.findByText('Coffee')).toBeInTheDocument();
    expect(screen.queryByText('Tea')).not.toBeInTheDocument();
  });
});
```

---

## Time Estimate

**Estimated**: 3 hours (components) + 1 hour (styling) + 1 hour (testing)
**Actual**: ___ hours

---

## Notes

- LocalizedString support (currently hardcoded to 'en-US')
- Money amounts come as BigInt from proto (convert to number for display)
- Category hierarchy (n-level) shown flat for MVP
- Consider virtual scrolling for large item lists (future)
- Image lazy loading for performance
- ConnectRPC automatically handles CORS and authentication headers
- TanStack Query provides automatic caching and background refetching

---

## Related Stories

- **S1.8**: Generate Code from Protos (provides types)
- **S1.15**: Cash Payment UI (uses selected items)
- **S2.5**: Modifier Selection (enhances item selection)
