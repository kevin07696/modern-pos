# S1.10: Process Cash Payment

**Sprint**: 1
**Story Points**: 5
**Assignee**: Developer A
**Priority**: P0 - Critical
**Dependencies**: S1.9 (Create Sale with Tax)

---

## User Story

As a **cashier**, I want to **process cash payments and calculate change** so that **I can complete sales quickly and accurately at the counter**.

---

## Description

Implement the cash payment processing logic in the Order Fulfillment Service. This includes validating payment amounts, calculating change, updating sale status to completed, creating payment records, and publishing sale.completed events.

Cash is the simplest payment method and doesn't require external service integration, making it perfect for MVP and offline mode.

---

## Acceptance Criteria

### Payment Processing
- [ ] Validate sale exists and status is pending
- [ ] Validate amount tendered >= sale total
- [ ] Calculate change (amount tendered - total)
- [ ] Create sale_payment record with method='cash'
- [ ] Update sale status to completed
- [ ] Set sale processed_at timestamp

### Business Rules
- [ ] Cannot pay for already-completed sale
- [ ] Cannot pay for voided/refunded sale
- [ ] Change calculation accurate to 2 decimal places
- [ ] Idempotent (calling twice with same data safe)

### Event Publishing
- [ ] Publish sale.completed event to Redis
- [ ] Event includes sale ID, sale number, location ID
- [ ] Event triggers kitchen display update
- [ ] Event triggers receipt generation

### Error Handling
- [ ] Return error if sale not found
- [ ] Return error if sale not pending
- [ ] Return error if payment amount insufficient
- [ ] Clear error messages in response

---

## Definition of Done

- [x] ProcessPayment domain service implemented
- [x] ConnectRPC handler implemented
- [x] Database transaction used (atomic)
- [x] Unit tests passing (>80% coverage)
- [x] Integration tests with database
- [x] Redis event publishing working
- [x] Manual testing completed
- [x] Code reviewed and approved
- [x] Deployed to dev environment

---

## Technical Details

### Domain Service Implementation

```go
// services/order-fulfillment/internal/domain/payment_service.go

package domain

import (
    "context"
    "fmt"
    "time"

    "github.com/google/uuid"
    orderv1 "github.com/modernpos/pos/gen/proto/go/order/v1"
)

type PaymentService struct {
    saleRepo    SaleRepository
    paymentRepo PaymentRepository
    eventPublisher EventPublisher
}

func (s *PaymentService) ProcessCashPayment(
    ctx context.Context,
    saleID uuid.UUID,
    amountTendered int64, // In cents
) (*orderv1.Payment, *orderv1.Sale, int64, error) {
    // 1. Get sale
    sale, err := s.saleRepo.GetByID(ctx, saleID)
    if err != nil {
        return nil, nil, 0, fmt.Errorf("sale not found: %w", err)
    }

    // 2. Validate sale status
    if sale.Status != orderv1.SaleStatus_SALE_STATUS_PENDING {
        return nil, nil, 0, fmt.Errorf("sale status must be pending, got: %v", sale.Status)
    }

    // 3. Validate payment amount
    saleTotal := sale.Total.Amount
    if amountTendered < saleTotal {
        return nil, nil, 0, fmt.Errorf(
            "insufficient payment: tendered %d, required %d",
            amountTendered, saleTotal,
        )
    }

    // 4. Calculate change
    change := amountTendered - saleTotal

    // 5. Create payment record
    payment := &orderv1.Payment{
        Id:                  uuid.New().String(),
        SaleId:              saleID.String(),
        TransactionGroupId:  uuid.New().String(),
        Method:              orderv1.PaymentMethod_PAYMENT_METHOD_CASH,
        Amount:              &commonv1.Money{Amount: saleTotal, CurrencyCode: sale.Total.CurrencyCode},
        Status:              orderv1.PaymentStatus_PAYMENT_STATUS_COMPLETED,
        AmountTendered:      &commonv1.Money{Amount: amountTendered, CurrencyCode: sale.Total.CurrencyCode},
        ChangeGiven:         &commonv1.Money{Amount: change, CurrencyCode: sale.Total.CurrencyCode},
        ProcessedAt:         timestamppb.Now(),
        CreatedAt:           timestamppb.Now(),
    }

    // 6. Update sale status (within transaction)
    now := time.Now()
    sale.Status = orderv1.SaleStatus_SALE_STATUS_COMPLETED
    sale.ProcessedAt = timestamppb.New(now)
    sale.UpdatedAt = timestamppb.New(now)

    // 7. Save within transaction
    err = s.saleRepo.WithTransaction(ctx, func(txCtx context.Context) error {
        if err := s.paymentRepo.Create(txCtx, payment); err != nil {
            return err
        }
        if err := s.saleRepo.UpdateStatus(txCtx, saleID, sale.Status, &now); err != nil {
            return err
        }
        return nil
    })
    if err != nil {
        return nil, nil, 0, fmt.Errorf("transaction failed: %w", err)
    }

    // 8. Publish event (after transaction commits)
    s.eventPublisher.PublishSaleCompleted(ctx, sale)

    return payment, sale, change, nil
}
```

### ConnectRPC Handler

```go
// services/order-fulfillment/internal/handlers/order_handler.go

func (h *OrderHandler) ProcessPayment(
    ctx context.Context,
    req *connect.Request[orderv1.ProcessPaymentRequest],
) (*connect.Response[orderv1.ProcessPaymentResponse], error) {
    // Extract request
    saleID, err := uuid.Parse(req.Msg.SaleId)
    if err != nil {
        return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid sale ID"))
    }

    // Validate payment method
    if req.Msg.Method != orderv1.PaymentMethod_PAYMENT_METHOD_CASH {
        return nil, connect.NewError(connect.CodeUnimplemented, fmt.Errorf("only cash supported in MVP"))
    }

    // Validate amount tendered
    if req.Msg.AmountTendered == nil || req.Msg.AmountTendered.Amount <= 0 {
        return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("amount_tendered required for cash"))
    }

    // Process payment
    payment, sale, change, err := h.paymentService.ProcessCashPayment(
        ctx,
        saleID,
        req.Msg.AmountTendered.Amount,
    )
    if err != nil {
        return nil, connect.NewError(connect.CodeInternal, err)
    }

    // Return response
    return connect.NewResponse(&orderv1.ProcessPaymentResponse{
        Payment: payment,
        Sale:    sale,
        Change:  &commonv1.Money{Amount: change, CurrencyCode: sale.Total.CurrencyCode},
    }), nil
}
```

### Database Queries (SQLC)

```sql
-- queries/sale.sql

-- name: UpdateSaleStatus :exec
UPDATE sales
SET status = $2,
    processed_at = $3,
    updated_at = NOW()
WHERE id = $1;

-- name: CreatePayment :exec
INSERT INTO sale_payments (
    id, sale_id, transaction_group_id,
    method, amount, status,
    card_type, last4, approval_code,
    processed_at, created_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6,
    $7, $8, $9,
    $10, $11
);
```

---

## Implementation Steps

1. Create `internal/domain/payment_service.go`
2. Implement `ProcessCashPayment` method with validation
3. Add change calculation logic
4. Create SQLC queries for payment creation
5. Add `UpdateSaleStatus` SQLC query
6. Implement transaction wrapper in repository
7. Create ConnectRPC handler `ProcessPayment`
8. Add request validation in handler
9. Implement event publishing (see S1.11)
10. Write unit tests for domain service
11. Write integration tests with database
12. Manual testing with Postman/curl
13. Test idempotency (call twice)
14. Test error cases (invalid sale, insufficient amount)

---

## Testing

### Unit Tests

```go
func TestPaymentService_ProcessCashPayment(t *testing.T) {
    t.Run("successful cash payment", func(t *testing.T) {
        // Setup mocks
        saleRepo := &mockSaleRepo{}
        paymentRepo := &mockPaymentRepo{}
        eventPublisher := &mockEventPublisher{}

        service := &PaymentService{
            saleRepo: saleRepo,
            paymentRepo: paymentRepo,
            eventPublisher: eventPublisher,
        }

        // Create pending sale
        saleID := uuid.New()
        sale := &orderv1.Sale{
            Id: saleID.String(),
            Status: orderv1.SaleStatus_SALE_STATUS_PENDING,
            Total: &commonv1.Money{Amount: 1050, CurrencyCode: "USD"}, // $10.50
        }
        saleRepo.sales[saleID] = sale

        // Process payment
        payment, updatedSale, change, err := service.ProcessCashPayment(
            context.Background(),
            saleID,
            2000, // $20.00
        )

        // Assert
        require.NoError(t, err)
        assert.Equal(t, int64(950), change) // $9.50 change
        assert.Equal(t, orderv1.SaleStatus_SALE_STATUS_COMPLETED, updatedSale.Status)
        assert.Equal(t, orderv1.PaymentStatus_PAYMENT_STATUS_COMPLETED, payment.Status)
        assert.True(t, eventPublisher.publishedSaleCompleted)
    })

    t.Run("insufficient payment amount", func(t *testing.T) {
        // Test insufficient payment
        _, _, _, err := service.ProcessCashPayment(ctx, saleID, 500) // $5.00, need $10.50
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "insufficient payment")
    })

    t.Run("sale already completed", func(t *testing.T) {
        // Test duplicate payment
        sale.Status = orderv1.SaleStatus_SALE_STATUS_COMPLETED
        _, _, _, err := service.ProcessCashPayment(ctx, saleID, 2000)
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "status must be pending")
    })
}
```

### Manual Test Cases

**Test 1: Successful cash payment**
```bash
curl -X POST http://localhost:8080/order.v1.OrderFulfillmentService/ProcessPayment \
  -H "Content-Type: application/json" \
  -d '{
    "sale_id": "550e8400-e29b-41d4-a716-446655440000",
    "method": "PAYMENT_METHOD_CASH",
    "amount_tendered": {"amount": 2000, "currency_code": "USD"}
  }'

# Expected: 200 OK
# Expected: payment object with change = 950 ($9.50)
# Expected: sale status = SALE_STATUS_COMPLETED
```

**Test 2: Insufficient payment**
```bash
curl -X POST ... -d '{
    "sale_id": "...",
    "method": "PAYMENT_METHOD_CASH",
    "amount_tendered": {"amount": 500, "currency_code": "USD"}
  }'

# Expected: 400 Invalid Argument
# Expected: Error message "insufficient payment"
```

---

## Time Estimate

**Estimated**: 3 hours (implementation) + 2 hours (testing)
**Actual**: ___ hours

---

## Notes

- Cash is MVP payment method (no external service calls)
- Change calculation uses integer math (cents) to avoid float errors
- Database transaction ensures atomicity (payment + status update)
- Event published AFTER transaction commits (not before)
- Idempotent by design - calling twice for completed sale returns error
- Consider adding payment receipt number for auditing (future)
- Offline mode uses same logic (synced later)

---

## Related Stories

- **S1.9**: Create Sale with Tax (prerequisite)
- **S1.11**: Publish sale.completed Event (event integration)
- **S1.15**: Cash Payment UI (frontend integration)
- **S2.8**: Process Card Payment (card payment extension)
