# S1.11: Publish sale.completed Event

**Sprint**: 1
**Story Points**: 3
**Assignee**: Developer A
**Priority**: P0 - Critical
**Dependencies**: S1.10 (Process Cash Payment)

---

## User Story

As a **system**, I want to **publish sale.completed events to Redis** so that **other services can react to completed sales (kitchen display, receipt printer, stock depletion)**.

---

## Description

Implement event publishing using Redis pub/sub to notify other services when a sale is completed. This enables decoupled architecture where the Communication Service can listen for events and update kitchen displays, the Item Management Service can deplete stock, and receipts can be generated automatically.

---

## Acceptance Criteria

- [ ] Redis client configured in Order Fulfillment Service
- [ ] Event publisher interface defined
- [ ] sale.completed event published after payment
- [ ] Event contains sale ID, display number, location ID, items
- [ ] Event published to `sales:completed` Redis channel
- [ ] Error handling for Redis failures (log but don't block sale)
- [ ] Integration test verifying event published

---

## Definition of Done

- [x] EventPublisher interface implemented
- [x] Redis adapter for EventPublisher
- [x] sale.completed event structure defined
- [x] Event published in ProcessCashPayment
- [x] Unit tests with mock publisher
- [x] Integration tests with Redis
- [x] Manual testing with redis-cli
- [x] Code reviewed and approved

---

## Technical Details

### Event Structure

```go
type SaleCompletedEvent struct {
    EventID       string    `json:"event_id"`
    EventType     string    `json:"event_type"` // "sale.completed"
    Timestamp     time.Time `json:"timestamp"`
    SaleID        string    `json:"sale_id"`
    DisplayNumber int32     `json:"display_number"`  // Customer-facing: #123
    LocationID    string    `json:"location_id"`
    Total         int64     `json:"total"`        // In cents
    Currency      string    `json:"currency"`
    Items         []Item    `json:"items"`
    OrderType     string    `json:"order_type"`
}

type Item struct {
    ItemID    string   `json:"item_id"`
    Name      string   `json:"name"`
    Quantity  float64  `json:"quantity"`
    Modifiers []string `json:"modifiers"`
}
```

### Implementation

```go
// internal/ports/event_publisher.go
package ports

type EventPublisher interface {
    PublishSaleCompleted(ctx context.Context, sale *orderv1.Sale) error
}

// internal/adapters/redis_event_publisher.go
package adapters

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/redis/go-redis/v9"
)

type RedisEventPublisher struct {
    client *redis.Client
}

func NewRedisEventPublisher(redisURL string) (*RedisEventPublisher, error) {
    opts, err := redis.ParseURL(redisURL)
    if err != nil {
        return nil, err
    }

    client := redis.NewClient(opts)

    // Test connection
    if err := client.Ping(context.Background()).Err(); err != nil {
        return nil, fmt.Errorf("redis connection failed: %w", err)
    }

    return &RedisEventPublisher{client: client}, nil
}

func (p *RedisEventPublisher) PublishSaleCompleted(
    ctx context.Context,
    sale *orderv1.Sale,
) error {
    // Build event
    event := map[string]interface{}{
        "event_id":       uuid.New().String(),
        "event_type":     "sale.completed",
        "timestamp":      time.Now().Format(time.RFC3339),
        "sale_id":        sale.Id,
        "display_number": sale.DisplayNumber,
        "location_id":    sale.LocationId,
        "total":          sale.Total.Amount,
        "currency":       sale.Total.CurrencyCode,
        "order_type":     sale.OrderType.String(),
        "items":          buildItemsForEvent(sale.Items),
    }

    // Serialize
    data, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %w", err)
    }

    // Publish to channel
    channel := "sales:completed"
    if err := p.client.Publish(ctx, channel, data).Err(); err != nil {
        // Log error but don't fail the sale
        log.Error("failed to publish sale.completed event", "error", err)
        return nil // Don't block sale on event failure
    }

    log.Info("published sale.completed event", "sale_id", sale.Id, "channel", channel)
    return nil
}

func buildItemsForEvent(saleItems []*orderv1.SaleItem) []map[string]interface{} {
    items := make([]map[string]interface{}, len(saleItems))
    for i, item := range saleItems {
        items[i] = map[string]interface{}{
            "item_id":  item.ItemId,
            "name":     item.Name,
            "quantity": item.Quantity,
            "modifiers": extractModifierNames(item.Modifiers),
        }
    }
    return items
}
```

---

## Implementation Steps

1. Add Redis client dependency (`github.com/redis/go-redis/v9`)
2. Create `EventPublisher` port interface
3. Create `RedisEventPublisher` adapter
4. Add Redis connection configuration (env var: REDIS_URL)
5. Implement `PublishSaleCompleted` method
6. Define event JSON structure
7. Integrate into `PaymentService.ProcessCashPayment`
8. Add error logging (don't fail sale on publish error)
9. Write unit tests with mock publisher
10. Write integration tests with test Redis
11. Test with redis-cli SUBSCRIBE
12. Document event format

---

## Testing

### Manual Test with redis-cli

```bash
# Terminal 1: Subscribe to channel
redis-cli
SUBSCRIBE sales:completed

# Terminal 2: Complete a sale via API
curl -X POST http://localhost:8080/.../ProcessPayment ...

# Terminal 1 should show:
{
  "event_id": "...",
  "event_type": "sale.completed",
  "timestamp": "2025-11-04T10:30:00Z",
  "sale_id": "...",
  "display_number": 123,
  "location_id": "...",
  "total": 1050,
  "currency": "USD",
  "items": [...]
}
```

### Integration Test

```go
func TestRedisEventPublisher_PublishSaleCompleted(t *testing.T) {
    // Setup test Redis
    redisContainer := setupTestRedis(t)
    defer redisContainer.Terminate(context.Background())

    publisher, err := NewRedisEventPublisher(redisContainer.URI)
    require.NoError(t, err)

    // Subscribe to channel
    subscriber := redis.NewClient(&redis.Options{Addr: redisContainer.Addr})
    pubsub := subscriber.Subscribe(context.Background(), "sales:completed")
    defer pubsub.Close()

    // Publish event
    sale := &orderv1.Sale{
        Id:            uuid.New().String(),
        DisplayNumber: 123,
        LocationId:    "loc-123",
        Total:         &commonv1.Money{Amount: 1050, CurrencyCode: "USD"},
    }

    err = publisher.PublishSaleCompleted(context.Background(), sale)
    require.NoError(t, err)

    // Verify received
    msg, err := pubsub.ReceiveTimeout(context.Background(), 2*time.Second)
    require.NoError(t, err)

    var event map[string]interface{}
    err = json.Unmarshal([]byte(msg.(*redis.Message).Payload), &event)
    require.NoError(t, err)

    assert.Equal(t, "sale.completed", event["event_type"])
    assert.Equal(t, sale.Id, event["sale_id"])
}
```

---

## Time Estimate

**Estimated**: 2 hours (implementation) + 1 hour (testing)
**Actual**: ___ hours

---

## Notes

- Redis pub/sub for real-time event distribution
- Event publishing should NOT block sale completion if Redis is down
- Log errors but don't fail the transaction
- Consider adding event queue/retry mechanism (future)
- Communication Service subscribes to this channel (S1.13)
- Item Management Service will also subscribe for stock depletion (Sprint 4)

---

## Related Stories

- **S1.10**: Process Cash Payment (triggers this event)
- **S1.13**: WebSocket Infrastructure (consumes this event)
- **S3.11**: Stock Depletion on Sale (consumes this event)
